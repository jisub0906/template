---
description: 
globs: 
alwaysApply: true
---
# 📏 Next.js + Supabase 개발 규칙

## 🎯 핵심 개발 원칙

### 1. 사용자 우선
- 개발자 편의 < 사용자 경험
- 기술적 우아함 < 실제 가치
- 복잡한 구현 < 단순한 해결책

### 2. 일관성 유지
- 모든 코드에서 동일한 패턴
- 파일 구조와 명명 규칙 준수
- 설계 원칙의 일관된 적용

### 3. 확장성 고려
- 미래 변화에 유연하게 대응
- 모듈화된 구조 설계
- 의존성 최소화

### 4. 성능 최적화
- 사용자가 체감할 수 있는 수준
- 불필요한 최적화는 지양
- 측정 가능한 개선

### 5. 보안 우선
- 모든 입력은 검증
- 최소 권한 원칙
- 민감 정보 보호

---

## 🏗️ 프로젝트 구조

### 폴더 구조
```
src/
├── app/                # Next.js 페이지 (App Router)
├── components/         # 재사용 컴포넌트
│   ├── ui/            # 기본 UI (Button, Input)
│   ├── common/        # 공통 (Header, Footer)
│   ├── forms/         # 폼 컴포넌트
│   └── layouts/       # 레이아웃
├── hooks/             # 커스텀 훅
├── lib/               # 유틸리티, 설정
├── store/             # 전역 상태
└── types/             # TypeScript 타입
```

### 명명 규칙
- **컴포넌트**: `UserProfile.tsx` (PascalCase)
- **훅**: `useAuth.ts` (camelCase + use 접두사)
- **유틸리티**: `formatDate.ts` (camelCase)
- **타입**: `User.ts` (PascalCase)
- **상수**: `API_ENDPOINTS.ts` (SCREAMING_SNAKE_CASE)
- **폴더**: `user-profile/` (kebab-case)

---

## 🧩 컴포넌트 개발

### 작성 원칙
1. **단일 책임**: 한 컴포넌트 = 한 역할
2. **명확한 Props**: 필요한 것만, 타입 명시
3. **재사용성**: 다른 곳에서도 사용 가능
4. **테스트 용이**: 간단하게 테스트 가능
5. **접근성**: 키보드, 스크린 리더 지원

### 계층 구조
```
Pages → Layouts → Sections → Components → UI → Elements
```

### Props 가이드라인
- **필수 props**: 동작에 꼭 필요한 것만
- **기본값**: 선택적 props에 기본값 제공
- **이벤트**: `on` 접두사 (`onClick`, `onSubmit`)
- **불린**: `is`, `has`, `can` 접두사
- **children**: 유연성이 필요한 경우만

---

## 🔄 상태 관리

### 상태 분류
1. **로컬 상태**: 컴포넌트 내부 → `useState`
2. **서버 상태**: API 데이터 → `TanStack Query`
3. **전역 상태**: 여러 컴포넌트 공유 → `Zustand`
4. **폼 상태**: 폼 데이터 → `React Hook Form`
5. **URL 상태**: 라우팅 관련 → `useSearchParams`

### 원칙
- **가장 가까운 곳에**: 필요한 곳 근처에 상태 배치
- **prop drilling 방지**: 3단계 이상 시 Context 고려
- **불변성**: 상태 업데이트 시 새 객체 생성
- **단일 진실 공급원**: 중복 데이터 방지
- **명확한 초기값**: 모든 상태에 초기값 설정

### TanStack Query 규칙
- **쿼리 키**: 배열, 계층적 (`['users', userId, 'posts']`)
- **캐시 설정**: 데이터 특성에 맞는 `staleTime`
- **에러 처리**: 전역과 로컬 분리
- **낙관적 업데이트**: UX 향상을 위해 활용

---

## 🎨 스타일링

### TailwindCSS 원칙
1. **유틸리티 우선**: 커스텀 CSS보다 Tailwind 클래스
2. **모바일 퍼스트**: 작은 화면부터 설계
3. **일관된 간격**: Tailwind spacing scale 준수
4. **정의된 색상**: 색상 팔레트 내에서만 사용
5. **다크모드**: 처음부터 고려

### 클래스 작성
- **순서**: 레이아웃 → 크기 → 색상 → 타이포 → 기타
- **조건부**: `clsx` 또는 `cn` 유틸리티 사용
- **긴 클래스**: 가독성을 위해 여러 줄
- **재사용**: 자주 사용하는 조합은 컴포넌트화

### 반응형 원칙
- **브레이크포인트**: `sm:640px`, `md:768px`, `lg:1024px`, `xl:1280px`
- **터치 친화적**: 최소 44px 터치 타겟
- **가독성**: 모든 화면에서 읽기 쉬운 크기

---

## 📝 TypeScript

### 타입 정의 원칙
1. **명시적 타입**: `any` 사용 금지
2. **인터페이스 우선**: 객체 타입은 `interface`
3. **제네릭 활용**: 재사용 가능한 타입
4. **유니온 타입**: 정확한 값 범위 표현
5. **타입 가드**: 런타임 타입 검증

### 파일 구조
```
types/
├── api.ts        # API 관련
├── auth.ts       # 인증 관련
├── database.ts   # DB 스키마
├── common.ts     # 공통 타입
└── index.ts      # 재내보내기
```

### 명명 규칙
- **인터페이스**: `User`, `PostData`, `ApiResponse`
- **타입 별칭**: `Theme`, `Status`, `ErrorCode`
- **제네릭**: `T`, `K` 또는 의미 있는 이름
- **이벤트**: `HandleClick`, `FormSubmit`

---

## 🔒 보안

### 기본 원칙
1. **모든 입력 검증**: 클라이언트와 서버 양쪽
2. **최소 권한**: 필요한 최소한의 권한만
3. **민감 정보 보호**: 로그나 에러에 노출 금지
4. **HTTPS 필수**: 모든 통신 암호화
5. **정기 업데이트**: 의존성과 보안 패치

### Supabase RLS
- **모든 테이블 RLS 활성화**
- **사용자별 데이터 완전 분리**
- **정책 적용 전 반드시 테스트**
- **관리자 권한 별도 정책**

### 환경변수
- **민감 정보**: `.env.local`에만, Git 제외
- **공개 변수**: `NEXT_PUBLIC_` 접두사 명확히
- **프로덕션**: 배포 플랫폼에서 설정
- **기본값**: 개발용 안전한 기본값

---

## 🚀 성능

### 렌더링 최적화
1. **React.memo**: 불필요한 리렌더링 방지
2. **useMemo/useCallback**: 비용 큰 계산/함수 메모화
3. **코드 분할**: 페이지/기능별 동적 import
4. **이미지 최적화**: Next.js Image 컴포넌트
5. **번들 최적화**: 불필요한 라이브러리 제거

### 데이터 페칭
- **적절한 캐싱**: 데이터 특성에 맞는 전략
- **페이지네이션**: 대량 데이터 분할
- **프리페칭**: 필요할 데이터 미리 로딩
- **에러 재시도**: 네트워크 오류 자동 재시도

### 빌드 최적화
- **Tree Shaking**: 미사용 코드 제거
- **압축**: gzip/brotli 활용
- **CDN**: 정적 자산 CDN 사용
- **지연 로딩**: 필요 시점에 로드

---

## 🎬 애니메이션 (Framer Motion)

### 기본 원칙
- **의미있는 애니메이션**: 사용자 이해 도움
- **적절한 지속시간**: 0.2~0.5초 권장
- **성능 우선**: transform, opacity 위주
- **접근성 고려**: `prefers-reduced-motion` 지원

### 필수 패턴
```typescript
// 페이지 전환
const pageVariants = {
  initial: { opacity: 0, y: 20 },
  animate: { opacity: 1, y: 0 },
  transition: { duration: 0.4 }
}

// 호버 효과
const hoverVariants = {
  hover: { scale: 1.05, y: -4 },
  tap: { scale: 0.95 }
}

// 리스트 스태거
const listVariants = {
  visible: {
    transition: { staggerChildren: 0.1 }
  }
}
```

### 성능 & 접근성
- **transform 활용**: translate, scale 우선
- **모션 민감도**: `useReducedMotion()` 활용
- **60fps 유지**: 복잡한 애니메이션 분할

---

## 🧪 품질 관리

### 코드 품질 기준
1. **가독성**: 6개월 후에도 이해 가능
2. **일관성**: 프로젝트 전체 동일 패턴
3. **간결성**: 불필요한 복잡성 제거
4. **확장성**: 새 요구사항에 쉽게 대응
5. **성능**: 사용자 경험 저해하지 않는 수준

### 정기 점검
- **의존성**: 월 1회 보안 업데이트
- **성능**: 주요 페이지 Lighthouse 점수
- **접근성**: 키보드, 스크린 리더 테스트
- **보안**: 취약점 스캔, 권한 설정
- **피드백**: 정기 사용성 테스트

---

## 🔄 Git & 협업

### 커밋 메시지
```
<타입>(<범위>): <제목>

<본문>
<푸터>
```

**타입**: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

### 브랜치 전략
- **main**: 배포 가능한 상태
- **feature/기능명**: 새 기능
- **fix/버그명**: 버그 수정
- **hotfix/**: 긴급 수정

### 코드 리뷰
1. **건설적 피드백**: 문제점 + 해결책
2. **빠른 응답**: 24시간 내
3. **중요도 표시**: 필수 vs 제안
4. **긍정적 피드백**: 좋은 코드 칭찬
5. **학습 기회**: 지식 공유

---

## ⚡ 개발 효율성

### 효율성 향상
1. **템플릿 활용**: 반복 패턴 템플릿화
2. **자동화**: 반복 작업 스크립트화
3. **재사용 우선**: 기존 컴포넌트 최대 활용
4. **검증된 라이브러리**: 신뢰할 수 있는 것만
5. **공식 문서**: 항상 공식 문서 우선

### 디버깅
- **개발 도구**: React DevTools 적극 활용
- **적절한 로깅**: 의미 있는 로그 메시지
- **에러 경계**: 적절한 레벨에서 처리
- **타입 체크**: TypeScript strict 모드
- **린터**: ESLint 규칙 엄격 적용

---

## 🚀 배포 & 운영

### 배포 전 체크리스트
- [ ] 빌드 오류 없음
- [ ] 환경변수 설정
- [ ] 성능 지표 확인
- [ ] 보안 설정 검토
- [ ] 데이터베이스 준비

### 모니터링
- **에러 추적**: 실시간 모니터링
- **성능**: Core Web Vitals 추적
- **사용자 분석**: 핵심 지표 확인
- **알림**: 중요 이슈 즉시 알림
- **백업**: 정기 DB 백업

---

## 📋 일일 체크리스트

### 개발 시
- [ ] 파일명/폴더 구조 규칙 준수
- [ ] 컴포넌트 작성 원칙 적용
- [ ] TypeScript 타입 명시
- [ ] ESLint 경고 0개

### 커밋 전
- [ ] `pnpm build` 성공
- [ ] `pnpm type-check` 통과
- [ ] `pnpm lint` 통과
- [ ] 커밋 메시지 규칙 준수

### 배포 전
- [ ] 전체 기능 테스트
- [ ] 성능 지표 확인
- [ ] 보안 검토
- [ ] 문서 업데이트

---

## 🎯 성공을 위한 조언

1. **작은 것부터 완벽하게**: 복잡한 기능보다 기본기
2. **사용자 관점**: 개발자 편의 < 사용자 경험
3. **지속적 개선**: 완벽한 코드는 없다
4. **팀 소통**: 규칙은 모두가 이해하고 동의해야
5. **문서화**: 6개월 후 자신을 위해 기록

**규칙은 더 나은 코드를 위한 도구입니다. 상황에 따라 유연하게 적용하되, 일관성이 가장 중요합니다!** 🎯
